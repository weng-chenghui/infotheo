From HB Require Import structures.
From mathcomp Require Import all_ssreflect all_algebra fingroup finalg matrix.
From mathcomp Require Import mathcomp_extra contra Rstruct ring reals.
Require Import realType_ext realType_ln ssr_ext ssralg_ext bigop_ext fdist.
Require Import proba jfdist_cond entropy graphoid.

(* Iwamoto2024: https://doi.org/10.1587/transfun.2023TAI0001 *)

Set Implicit Arguments.
Unset Strict Implicit.
Import Prenex Implicits.

Import GRing.Theory Num.Theory.

Local Open Scope ring_scope.
Local Open Scope reals_ext_scope.
Local Open Scope proba_scope.
Local Open Scope fdist_scope.
Local Open Scope entropy_scope.
Local Open Scope vec_ext_scope.

Reserved Notation "u *d w" (at level 40).
Reserved Notation "u \*d w" (at level 40).

Section shamirss.
Context {R : realType}.
Variables (T : finType) (m k : nat).
Let k' := k.-1. 
Let TX := [the finComRingType of 'I_m.+2].
Let VX := 'rV[TX]_k'.
Variables (s : TX) (v_c : 'rV[TX]_k') (r_k' : 'rV[TX]_k').
Let psi_C' := fun v_c : 'rV[TX]_k' => r_k'.
About psi_C'.
(* The type: psi_C' : 'rV_k' -> 'rV_k' is not useful.
   In Iwamoto2024, the \psi_C between eqn 8 and 9 looks typed with something
   more than just vectors of TX, but not yet random variables:

   \psi_C: (s,vi1 ,vi2 ,...,vik−1 ) |-> (s,r1,r2,...,rk−1).

   Anyway, the critical property about \psi_C is injectivity.
   To prove it we need to implement the function,
   then use can_inj.
*)
Let psi_C'_inj : injective psi_C'.
Admitted.

Variables (U : finType).
(* Because entropy_fdistmap requires a fdist with A and B,
   where in psi_C function A and B are 'rV[TX]_k',
   we must assign the vector type as the type in distribution if we want to use
   the lemma.

Variables (P : R.-fdist 'rV[TX]_k').
*)
Variables (P : R.-fdist U).
Variables (S : {RV P -> TX}).
Variables (V_C : {RV P -> 'rV[TX]_k'}) (R_K' : {RV P -> 'rV[TX]_k'}).

(* pull/161 *)
Let mutual_info_RVX  (C D : finType) (X : {RV P -> C}) (Y : {RV P -> D}):
  `I(X; Y) = `I(Y; X).
Proof. by rewrite /mutual_info_RV mutual_info_sym fdistX_RV2. Qed.

(* pull/161 *)
Let mutual_info_RVE  (C D : finType) (X : {RV P -> C}) (Y : {RV P -> D}):
  `I(X;Y) = `H `p_X - `H(X | Y).
Proof. Admitted.

(* pull/158 *)
Let joint_entropy_RVX  (A B : finType) (f : A -> B)
(RA : {RV P -> A}) (RB : {RV P -> B}) (X : {RV P -> TX}):
  injective f -> `H(RA, X) = `H(RB, X).
Proof. Admitted.

Hypothesis card_K' : #|'rV[TX]_k'| = k.+1.

(* Although we wrote R_K' respects the distribution P, the fdist_uniform card_K'
   generates a new distribution `#|A| = n.+1 -> R.-fdist A` and is assigned to
   R_K' by this hypothesis. Whether this by design overwrites the original P?
   It looks like the design allows one RV has two distributions,
   and the uniform one can be used when it is needed in proofs.

   Because in some occasions like P |= V_C _|_ R_K', we need them to have the
   same distribution. But in other occasions, we need R_K' to have the uniform
   distribution since it is purely generated by the RNG.
*)
Hypothesis pR_K'_unif : `p_ R_K' = fdist_uniform card_K'.
Hypothesis indep_R_K'_S : P |= R_K' _|_ S.

Let H_VC_RK_eq0:
  `H `p_ V_C - `H `p_ R_K' = 0.
Proof.
Abort.

(* --- Two lemmans for a simpler way to prove joint_entropy_RV_indepE *)
About mutual_info0P.
About mutual_infoE3.
Locate "`x".
(* Ref: https://math.stackexchange.com/a/3519362/1366109 *)
Let joint_entropy_RV_indepE (A B : finType) (X : {RV P -> A}) (Y : {RV P -> B}):
  P |= X _|_ Y -> `H(X, Y) = `H `p_ X + `H `p_ Y.
Proof.
(* Cannot rewrite pr_eqE' in forall X Y. Need two `under`. *)
rewrite /inde_RV.  
under [forall (X : A), _ ]boolp.eq_forall do
under boolp.eq_forall do rewrite !pr_eqE'.
move => Hinde.
(*
rewrite /inde_RV => Hinde.
have H y x : `p_ [%X, Y] (x, y) = `p_ X x * `p_ Y y.
  have H2 := (Hinde x y).
  rewrite !pr_eqE' in H2.
  exact: H2.
*)
rewrite joint_entropy_RVC.
rewrite /joint_entropy_RV joint_entropyC fdistX_RV2.
rewrite !entropy_Ex !E_opp_RV.
rewrite -opprB.
congr (- _).
rewrite opprK.
(* Worth a E_log_add lemma? *)
rewrite /Ex.
rewrite (eq_bigr (fun u => `log (`p_ [% X, Y]) (u.1, u.2) *
  `p_ [% X, Y] (u.1, u.2) )); last by case.
rewrite -(pair_bigA _ (fun x y => 
  `log (`p_ [% X, Y]) (x, y) * `p_ [% X, Y] (x, y)))  /=.
rewrite /log_RV.
under eq_bigr do under eq_bigr do rewrite !Hinde.
transitivity (\sum_i \sum_i0 (log (`p_ X i) +
  log (`p_ Y i0)) * (`p_ X i * `p_ Y i0) ).
  apply eq_bigr => a _.
  apply eq_bigr => b _.
    (*case analysis: 0 < `p_ Y b and 0 < `p_ X a for logM *)
    have [->| /fdist_gt0 Hb] := eqVneq (`p_ Y b) 0.
      by rewrite !mulr0.
    have [->| /fdist_gt0 Ha] := eqVneq (`p_ X a) 0.
      by rewrite !mul0r !mulr0.
    rewrite logM //.
under eq_bigr do under eq_bigr do rewrite mulrDl.
under eq_bigr do rewrite big_split -!big_distrr /=.
rewrite big_split FDist.f1 /=.
under eq_bigr do rewrite mulr1.
rewrite addrC.
congr (_ + _).
rewrite exchange_big /=.
apply eq_bigr => b _.
rewrite -big_distrr -big_distrl FDist.f1 /=.
by rewrite mul1r.
Qed.

Let mutual_info_S_R_K'_eq0 :
  `I(S; R_K') = 0.
Proof.
rewrite mutual_info_RVE.
have ->: `H( S | R_K') = `H(R_K', S) - `H `p_ R_K'.
  by rewrite chain_rule_RV addrAC addrC addrA addrK.
rewrite opprB addrA.
rewrite /joint_entropy_RV joint_entropyC fdistX_RV2.
have ->: `H `p_ [% S, R_K'] = `H(R_K', S).
  by rewrite /joint_entropy_RV joint_entropyC fdistX_RV2.
rewrite joint_entropy_RV_indepE; last by exact indep_R_K'_S.
by rewrite addrKA subrr.
Qed.

Lemma I_VC_S_E:
  `I(V_C; S) = `H `p_ V_C - `H `p_ R_K'.
Proof.
rewrite mutual_info_RVX.
rewrite mutual_info_RVE.
have ->: `H( S | V_C) = `H(V_C, S) - `H `p_ V_C.
  by rewrite chain_rule_RV addrAC addrC addrA addrK.
rewrite joint_entropy_RVC.
rewrite opprB addrA.
have H := joint_entropy_RVX V_C R_K' S psi_C'_inj.
rewrite joint_entropy_RVC in H.
rewrite H.
have ->: `H(R_K', S) = `H `p_ S + `H `p_ R_K' - `I(S; R_K').
  rewrite mutual_info_RVE.
  rewrite opprB addrA addrAC addrC addrAC addrA addrC addrA addrA addrK.
  exact: chain_rule_RV.
rewrite opprB addrA addrAC addrC addrAC addrA addrC addrA addrA opprB.
have ->: \sum_(a in matrix_matrix__canonical__fintype_Finite TX 1 k')
  `p_ R_K' a * log (`p_ R_K' a) = -(`H `p_ R_K').
  by rewrite /entropy opprK. (* opprB expands `H and -/entropy won't work *)
by rewrite addrA addrAC addrK mutual_info_S_R_K'_eq0 addrAC addr0.
Qed.




End shamirss.
